#〇.技术面试指导  
-------（必须）--------     
0.自我介绍  
表达流畅，不要太差即可

1.基础 	
自己百度常见面试题（不含答案）  
坑：【答案很标准】  
面试题的答案：一定不要背标准答案，一定要有自己的思想 (哪怕有少量错误)
常见的题，一定要会： arraylist/hashmap的源码、实现源码  ，冒泡排序/快速排序、 单例模式/工厂模式/动态工厂、谈谈你对面向对象的理解， 事务ACID/隔离级别 ，Spring IOC/AOP  

建议：   自己的理解  -> 搜博客/githug上搜大神的博文、理解 。可以将 面试题中的问题  在博客、github上搜答案，不要在面试题附带的答案上搜  
坑：不要写“精通”  
建议：掌握、熟练  ,理解 ，会使用

2.技术列表  
不要中规中矩:培训/看某套视频出来的  
java + 数据库+web前端+jsp/servlet+ssm +boot/cloud+ 2-3非培训机构标配课程(只要掌握该技术的1-2个核心点即可)   
-> 缺失个人独立思考的能力  
坑： 技术点，宁可少写，也别多写， 写多了可能是坑    
一般而言：简历上写到的技术，很可能被问到	  

3.项目
坑：电商、管理系统    ->培训机构标配，缺乏真实项目的感觉  
建议：  
	（1）.提前准备好回答的台词  
	（2）.技术本身的不足，如何弥补   -》技术、真实性  
		a.mysql、大型、海量   ： 如果数据超过的Mysql的容量怎么处理？  
		b.高并发项目，缓存： 在哪些场景 见过缓存失效？怎么解决？  
		c.MQ解决耦合性：哪些真实的场景 用到 解耦合？  
	（3）项目的重难点  
		a.分布式项目： 如何共享数据  
		b.高并发：  几级缓存，如何限流，如何熔断   
	（4）真实性：实际的使用场景  
		a.“用到的人脸识别技术”  ： 哪些场景用到了  
		b.多线程、设计模式、算法： 处理什么业务？场景？  
		c.大数据的项目？  数据从哪来？  
		d.如何设计表？外键  一对一  一对多如何  
		e.项目能否访问？    
	（5）描述：技术+文字  ， 项目周期：半年以上  ， 写几个？ 3以内 ：  2-3     毕业：1-2   

4.表达沟通能力  
  
-----加分-------  
1.高并发/分布式  
	a.多线程（juc,aqs,线程安全，锁机制，生产消费者）  
	b.数据处理  
		SQL优化  ，  mysql+mycat+haproxy+keepalived   

2.实际的解决问题能力  
	主动引入  
	回答项目： 遇到过什么问题、如何发现、排查、分析、解决、总结  
	主动、学习、能发现问题、解决  

 3.绝杀：  
ACM竞赛、蓝桥杯等全国性竞赛、出版	   
github发布一个项目(star很多) 、 博客、公众号、  	  	
个人已发布的项目（阿里云）、牛人推荐信  、JDK/spring/mybatis源码   
（电子简历：链接 		  纸质：二维码）


----注意/建议事项----   
1.体现数字：  几个项目、几篇博客 、排名第几  
2.工作：不要面议 ，  范围5000-8000  
3.简历： 1-2页（尽量不要空半页），不要书皮，格式PDF（wps word，可能出现兼容问题）, 外观不要太过绚丽  
4.细节： 	毕业时间、年龄、工作履历、期望薪资    

沟通：注意人文素养    ,不要抱怨问题， 要体现解决问题	  
建议： 个人解决的能力、团队、沟通  


#一.重载和重写的区别

|  | 方法名 | 参数列表 | 返回值 | 访问修饰符 | 抛出异常|
|- | - | - | - | - | -|
|方法重写 | 相同 | 相同 | 相同或是其子类 | 不能比父类更严格 | 不能比父类更宽泛|
|方法重载 |相同 | 不相同 | 无关 | 无关 | 无关|



#二.常见集合框架的底层数据结构  

题外话1：List和Set的上级接口是Collection，但Collection与Map之间不存在继承/实现关系。  
题外话2：本文中的是否“唯一”，是指集合中的元素值是否可以重复。  
有序/无序，是指输入集合的顺序 是否和 集合的存储顺序一致（或理解为输出顺序），例如，向集合依次输入a、b、c后，如果打印时也输出a、b、c就代表“有序”；如果打印时输出的是a、c、b（或b、a、c等）就代表“无序”。

Collection(不唯一、无序)
##1List(不唯一、有序)
- Arraylist： 线程不安全，Object数组 ，默认长度是10。  
扩容机制：当超过数组容量时，新数组是原来数组的1.5倍。JDK中的源码是：
```   
private void grow(int minCapacity) 
{  
  ...
  int newCapacity = oldCapacity + (oldCapacity >> 1);
}
```
- Vector： 线程安全，Object数组，默认长度是10。  
扩容机制：当超过数组容量时，新数组是原来数组的2倍。JDK中的源码是：
```
private void grow(int minCapacity) {
   ...
   int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                     capacityIncrement : oldCapacity);
```

LinkedList： 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) 。通过first和last引用分别指向链表的第一个和最后一个元素（元素用Node表示），Node的源码如下所示。

```

    private static class Node<E> {
        E item;
        Node<E> next;//下一个
        Node<E> prev;//上一个

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
```

##2Set
HashSet（唯一，无序）: 线程不安全，基于HashMap实现的，底层采用 HashMap 来保存元素  
LinkedHashSet： LinkedHashSet继承自HashSet，并且其内部是通过 LinkedHashMap来实现的。  
TreeSet（有序，唯一）： 红黑树

##3Map（以key-value形式存储数据，通过key取value。key不能重复，value可以重复。）
HashMap：线程不安全，通过ConcurrentHashMap解决。JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体（默认初始容量为16），数组中的每个元素是链表的形式。JDK1.8以后，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。 HashMap的加载因子为0.75：当元素个数 超过 容量长度的0.75倍 时，进行扩容。扩容增量：原容量的2倍.  
LinkedHashMap: LinkedHashMap 继承自HashMap。LinkedHashMap在上面结构的基础上，增加了一条双向链表，使得HashMap的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。  
HashTable: 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的
TreeMap: 红黑树  
ConcurrentHashMap：JDK8以前的ConcurrentHashMap间接的实现了Map<K,V>，并将每一个元素称为一个segment（默认16个），每个segment都是一个HashEntry<K,V>数组，数组的每个元素都是一个HashEntry的单向队列。JDK8以后，HashMap/ConcurrentHashMap的存储结构发生了改变：增加了条件性的“红黑树”。为了优化查询，当链表中的元素超过 8 个时，HashMap就会将该链表转换为红黑树，即采用了数组+链表/红黑树的存储结构。

#三.Arraylist 与 LinkedList 异同
**（1）是否保证线程安全**： ArrayList 和 LinkedList 都是线程不安全；  
**（2）底层数据结构**： Arraylist 底层使用的是Object数组；LinkedList  底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环）  
**（3）插入和删除是否受元素位置的影响**：  
*ArrayList*  采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。   
*LinkedList*采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O(1)而数组为近似 O(n)。  
**（4）是否支持快速随机访问**： LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。  
**（5）内存空间占用**：  ArrayList的空  间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。
 

#四.试述Forward和Redirect的区别
**（1）转发（Forword）是服务器行为，重定向（Redirect）是客户端行为**  
**转发**可以通过HttpServletRequest对象的getRequestDispatcher()方法链式调用forward()方法实现，如request.getRequestDispatcher().forward()。
**重定向**是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。转发可以通过HttpServletResponse对象的sendRedirect()方法实现。  
**（2）地址栏显示**:  转发是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来, 然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. 重定向是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.  
**（3）数据共享**: 转发:转发页面和转发到的页面可以共享request里面的数据. 重定向:不能共享数据  
**（4）实际运用**:  转发:一般用于用户登陆的时候,根据角色转发到相应的模块.  重定向:一般用于用户注销登陆时返回主页面和跳转到其它的网站等  
**（5）效率**： 转发:高. 重定向:低.

#五.如何设计一个秒杀系统？    

什么秒杀：  流量很大，库存少

**架构设计原则：**
  限流、缓存、隔离、降级和熔断

1.限流（多重）:尽量上级限流，负载 ,MQ流量削峰  

2.缓存（多级）:请求->redis->DB  

3.隔离：将秒杀的服务器隔离开  

4.降级和熔断：  
熔断：客户端 -> service() , beiYong(){return "未响应，请重试"}
降级：服务端 ：  20个服务->减少到10个服务


防止重复消费行为：幂等性  
	zs ：支付->支付服务(扣款)->返回（支付成功）
	幂等性实现：去重表，在每次支付前，先查看去重表中 是否有扣款记录。如果有，则返回文字提示“已扣款，请稍等响应页面”；如果没有，再执行扣款